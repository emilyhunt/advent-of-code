import{S as f,i as c,s as w,w as V,x as p,y as g,K as P,f as m,t as S,z as A}from"../../../../../chunks/index-69c26055.js";import{c as N,a as b}from"../../../../../chunks/stores-9a814c3a.js";import{R as M}from"../../../../../chunks/Runner-973d1dd1.js";class T{constructor(e){const a=e.replace(";","").replace("="," ").trim().split(" ");this.name=a[1],this.flowRate=Number(a[5]),this.neighbors=a.slice(10).map(l=>l.replace(",","")),this.hasNonzeroFlow=this.flowRate!==0}eventualPressureRelease(e){const a=30-e-1;if(a<0)throw"Negative remaining time was calculated";return this.flowRate*a}}function I(...v){let e=[],a=v.length-1;function l(t,n){for(let r=0,s=v[n].length;r<s;r++){let o=t.slice(0);o.push(v[n][r]),n==a?e.push(o):l(o,n+1)}}return l([],0),e}class u{constructor(e){this.nodes={},this.initialiseNodes(e),this.startingNode="AA",this.allPaths=[],this.allPathScores=[],this.bestPath,this.bestPathScore=0,this.meanScore=0,this.currentMaxScore=0,this.pruningMetadata={cycles:0,zeros:0,scoreLow:0},this.nodesWorthVisiting=[];for(const a in this.nodes)this.nodes[a].hasNonzeroFlow&&this.nodesWorthVisiting.push(a)}initialiseNodes(e){for(const a of e){const l=new T(a);this.nodes[l.name]=l}}calculateAllPaths(e,a,l){e===void 0&&(e=30),a===void 0&&(a=1),l===void 0&&(l=6);let t=[{path:[],openNodes:[],score:0,goodPath:!0,hasEnded:!1}];for(let n=0;n<a;n++){const r=[this.startingNode];t[0].path.push(r)}for(let n=1;n<=e;n++)this.checkAllPaths(t,n,l,a),t=t.filter(r=>r.goodPath),this.scorePaths(t,n),console.log(n,Object.keys(t).length,this.meanScore,this.pruningMetadata);if(this.allPaths=t,!this.allPaths.every(n=>n.path[0].length===e+1))throw"Some paths have incorrect length"}checkAllPaths(e,a,l,t){const n=e.length;for(let r=0;r<n;r++){const s=e[r];this.decideIfPathHasEnded(s,t),this.decideToPrunePath(e,a,l,s,t),!s.hasEnded&&s.goodPath&&this.addNeighbors(s,e,t)}}scorePaths(e){const a=[];for(const l of e)l.openNodes.length>0&&(l.score+=l.openNodes.map(t=>this.nodes[t].flowRate).reduce((t,n)=>t+n,0)),a.push(l.score);this.meanScore=a.reduce((l,t)=>l+t,0)/a.length,this.currentMaxScore=Math.max(...a)}decideIfPathHasEnded(e,a){if(e.hasEnded||e.openNodes.length===this.nodesWorthVisiting.length){const l=e.path[0].length-1;for(let t=0;t<a;t++)e.path[t].push(e.path[t][l]);e.hasEnded=!0}}decideToPrunePath(e,a,l,t,n){const r=.3333333333333333;if(!t.hasEnded&&a>3){const s=t.path[0].length-1;for(let o=0;o<n;o++)if(t.path[o][s]===t.path[o][s-2]&&t.path[o][s-1]===t.path[o][s-3]){t.goodPath=!1,this.pruningMetadata.cycles+=1;break}}if(!t.hasEnded&&a>l&&t.goodPath){t.score===0&&(t.goodPath=!1,this.pruningMetadata.zeros+=1);const s=this.meanScore+r*(this.currentMaxScore-this.meanScore);t.score<s&&e.length>5e3*n&&(t.goodPath=!1,this.pruningMetadata.scoreLow+=1)}}addNeighbors(e,a,l){const t=e.path[0].length-1,n=[];for(let s=0;s<l;s++){n.push([]);const o=this.nodes[e.path[s][t]].hasNonzeroFlow,h=e.path[s][t]===e.path[s][t-1];let i=e.openNodes.includes(e.path[s][t]);o&&h&&!i&&(e.openNodes.push(e.path[s][t]),i=!0),o&&!i&&n[s].push(e.path[s][t]),n[s].push(...this.nodes[e.path[s][t]].neighbors)}const r=I(...n);for(const s of r){const o=JSON.parse(JSON.stringify(e.path));for(let h=0;h<l;h++)o[h].push(s[h]);a.push({path:o,score:e.score,openNodes:[...e.openNodes],goodPath:!0,hasEnded:e.hasEnded})}e.goodPath=!1}getBestScore(){for(const e of this.allPaths)e.score>this.bestPathScore&&(this.bestPathScore=e.score,this.bestPath=e);return console.log(this.bestPath),this.bestPathScore}}function d(v){return v.trim().split(`
`)}function R(v){const e=new u(v);return e.calculateAllPaths(30),e.getBestScore()}function E(v){const e=new u(v);return e.calculateAllPaths(26,2,6),e.getBestScore()}const J=`Valve QZ has flow rate=0; tunnels lead to valves IR, FA
Valve FV has flow rate=0; tunnels lead to valves AA, GZ
Valve GZ has flow rate=0; tunnels lead to valves FV, PO
Valve QL has flow rate=0; tunnels lead to valves MR, AA
Valve AA has flow rate=0; tunnels lead to valves QL, GQ, EV, FV
Valve SQ has flow rate=23; tunnel leads to valve ZG
Valve PK has flow rate=8; tunnels lead to valves MN, GN, WF, TY, CX
Valve GQ has flow rate=0; tunnels lead to valves AA, MT
Valve TI has flow rate=22; tunnels lead to valves GM, CS
Valve JU has flow rate=17; tunnels lead to valves TT, RR, UJ, JY
Valve YD has flow rate=7; tunnels lead to valves AT, ZS, BS
Valve YB has flow rate=0; tunnels lead to valves EA, MW
Valve FA has flow rate=0; tunnels lead to valves QZ, JT
Valve TN has flow rate=0; tunnels lead to valves ZS, PO
Valve MW has flow rate=0; tunnels lead to valves YB, YL
Valve XN has flow rate=0; tunnels lead to valves VL, VM
Valve MN has flow rate=0; tunnels lead to valves PK, TT
Valve IP has flow rate=9; tunnels lead to valves YC, SA, CH, PI
Valve PD has flow rate=0; tunnels lead to valves YZ, VM
Valve ZS has flow rate=0; tunnels lead to valves TN, YD
Valve PC has flow rate=0; tunnels lead to valves MR, XT
Valve VM has flow rate=13; tunnels lead to valves CX, XN, PD
Valve PO has flow rate=4; tunnels lead to valves GZ, TN, SA, XT, BM
Valve GN has flow rate=0; tunnels lead to valves PK, YL
Valve YL has flow rate=5; tunnels lead to valves MT, YZ, GN, SU, MW
Valve IR has flow rate=6; tunnels lead to valves LK, PI, BM, QZ, EV
Valve GM has flow rate=0; tunnels lead to valves TI, RH
Valve CS has flow rate=0; tunnels lead to valves UJ, TI
Valve EA has flow rate=18; tunnels lead to valves VL, YB, WF, JY
Valve LK has flow rate=0; tunnels lead to valves IR, MR
Valve BM has flow rate=0; tunnels lead to valves IR, PO
Valve JZ has flow rate=0; tunnels lead to valves RH, RR
Valve SA has flow rate=0; tunnels lead to valves IP, PO
Valve XT has flow rate=0; tunnels lead to valves PO, PC
Valve YC has flow rate=0; tunnels lead to valves IP, IL
Valve RH has flow rate=15; tunnels lead to valves WJ, JZ, GM
Valve CH has flow rate=0; tunnels lead to valves IP, BS
Valve JY has flow rate=0; tunnels lead to valves EA, JU
Valve TY has flow rate=0; tunnels lead to valves WJ, PK
Valve WJ has flow rate=0; tunnels lead to valves TY, RH
Valve IL has flow rate=0; tunnels lead to valves YC, MR
Valve BS has flow rate=0; tunnels lead to valves YD, CH
Valve AT has flow rate=0; tunnels lead to valves YD, UX
Valve UJ has flow rate=0; tunnels lead to valves CS, JU
Valve VL has flow rate=0; tunnels lead to valves EA, XN
Valve JT has flow rate=21; tunnels lead to valves ZG, FA
Valve UX has flow rate=10; tunnel leads to valve AT
Valve RR has flow rate=0; tunnels lead to valves JZ, JU
Valve TT has flow rate=0; tunnels lead to valves JU, MN
Valve MT has flow rate=0; tunnels lead to valves GQ, YL
Valve EV has flow rate=0; tunnels lead to valves AA, IR
Valve ZG has flow rate=0; tunnels lead to valves JT, SQ
Valve WF has flow rate=0; tunnels lead to valves EA, PK
Valve YZ has flow rate=0; tunnels lead to valves PD, YL
Valve MR has flow rate=3; tunnels lead to valves LK, IL, QL, SU, PC
Valve PI has flow rate=0; tunnels lead to valves IR, IP
Valve CX has flow rate=0; tunnels lead to valves VM, PK
Valve SU has flow rate=0; tunnels lead to valves YL, MR

`,Y=`

Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
`;function D(v){let e,a;return e=new M({props:{part1:R,part2:E,preprocessor:d,metadata:C}}),{c(){V(e.$$.fragment)},l(l){p(e.$$.fragment,l)},m(l,t){g(e,l,t),a=!0},p:P,i(l){a||(m(e.$$.fragment,l),a=!0)},o(l){S(e.$$.fragment,l),a=!1},d(l){A(e,l)}}}const C={title:"Proboscidea Volcanium",day:"16",year:"2022",description:"The cave is about to fill up with lava! Which valves should we open to reduce pressure, and how much pressure will that release? (by FAR my slowest code yet, ouch. Could be optimised by: 1. compressing graph into just start & valves with flow > 0; 2. pre-finding the shortest paths between nodes using e.g. Djikstra's and storing this as a mapping; 3. guesstimating best path and running first; 4. brute force between all remaining paths, using some sort of permutation iterator; 5. pre-culling all paths that can't possibly be better than the current best (if this helps? may do for part 2); 6. using lookup table of how much flow a given valve will contribute given different opening times; 7. pre-culling paths that can't possibly visit as many nodes as the current best did; 8. using BFS and culling all potential routes that are invalid even in best case.)",longRuntime:!0,result1:"Total flow with best solution",result2:"Total flow with best two-worker solution",keywords:["TODO: OPTIMISE"],visible:!0};function F(v){return N.set(d(J)),b.set(d(Y)),[]}class Z extends f{constructor(e){super(),c(this,e,F,D,w,{})}}export{Z as default,C as myMetadata};
