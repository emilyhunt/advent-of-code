import{s as E,n as D}from"./scheduler.82952e60.js";import{S as T,i as P,k as z,m as $,o as B,p as I,q as O,r as A}from"./index.4f02d16c.js";import{c as F,a as M}from"./stores.7b94593c.js";import{R as N}from"./Runner.63361570.js";const u="Blizzard Basin",f="24",d="2022",g="We need to get through a blizzard to get to the extraction point! This was yet another fun adventure in searches. My solution could probably be a bit quicker if it was less object-oriented, though I really like how readable that makes it.",m=!1,p="Shortest route to end",w="Shortest route from start, to end, to start",S=["TODO: COMMENT","TODO: OPTIMISE","object oriented","bfs","cyclical"],y=!0,X={title:u,day:f,year:d,description:g,longRuntime:m,result1:p,result2:w,keywords:S,visible:y},Y=Object.freeze(Object.defineProperty({__proto__:null,day:f,default:X,description:g,keywords:S,longRuntime:m,result1:p,result2:w,title:u,visible:y,year:d},Symbol.toStringTag,{value:"Module"}));function L(n,v,t){return Array.from(Array(n),e=>Array(v).fill(t))}class a{constructor(v,t,e,r){this.up=v,this.right=t,this.down=e,this.left=r}hasBlizzard(){return this.up||this.right||this.down||this.left}static fromInputData(v){const t=a.newEmptyPoint();if(v==="^")t.up=!0;else if(v===">")t.right=!0;else if(v==="v")t.down=!0;else if(v==="<")t.left=!0;else if(v!==".")throw`Input blizzard direction '${v}' not recognised!`;return t}static newEmptyPoint(){return new a(!1,!1,!1,!1)}copy(){return new a(this.up,this.right,this.down,this.left)}}class b{constructor(v){this.height=v.length,this.width=v[0].length,this.cycleLength=this.width*this.height,this.state=[],this.currentState=0;for(let t=0;t<this.height;t++){this.state.push([]);for(let e=0;e<this.width;e++)this.state[t].push(a.fromInputData(v[t][e]))}this.solvedStates=[],this.convertStateToBoolean()}convertStateToBoolean(){const v=this.state.map(t=>t.map(e=>e.hasBlizzard()));this.solvedStates.push(v)}calculateNextState(){const v=this.state.map(t=>t.map(e=>a.newEmptyPoint()));for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)this.moveBlizzardAtPoint(t,e,v);this.state=v}moveBlizzardAtPoint(v,t,e){const r=this.state[v][t];if(r.up){let s=v-1;s<0&&(s=this.height-1),e[s][t].up=!0}if(r.down){let s=v+1;s>=this.height&&(s=0),e[s][t].down=!0}if(r.right){let s=t+1;s>=this.width&&(s=0),e[v][s].right=!0}if(r.left){let s=t-1;s<0&&(s=this.width-1),e[v][s].left=!0}}getNextState(){return this.currentState++,this.currentState>=this.cycleLength?this.solvedStates[this.currentState%this.cycleLength]:(this.calculateNextState(),this.convertStateToBoolean(),this.solvedStates[this.currentState])}getAllStates(v){v&&(console.log("DEBUGGING MODE"),console.log("Total number of cycles:",this.cycleLength),console.log("Initial state:"),console.log(this.currentStateToString()));let t=1;for(;t<=this.cycleLength;)this.calculateNextState(),this.convertStateToBoolean(),v&&(console.log(`State ${t}:`),console.log(this.currentStateToString())),t++;for(let e=0;e<this.height;e++)for(let r=0;r<this.width;r++)if(this.solvedStates[0][e][r]!==this.solvedStates[this.cycleLength][e][r])throw`Initial state is not equal to theoretical next cycle state at ${r},${e}!`;return this.solvedStates.slice(0,-1)}currentStateToString(){const v=L(this.height,this.width,".");for(let t=0;t<this.height;t++)for(let e=0;e<this.height;e++){const r=this.state[t][e],s=r.up+r.right+r.down+r.left;s>1?v[t][e]=s:s===1&&(v[t][e]=r.up?"^":r.right?">":r.down?"v":"<")}return v.map(t=>t.join("")).join(`
`)}}class o{constructor(v,t,e,r){this.x=v,this.y=t,this.length=e,this.history=r,this.distanceFromEnd=void 0}static atStart(v,t){return t?new o(v.startX,v.startY,0,["S"]):new o(v.startX,v.startY,0)}recordMove(v){this.length+=1,this.history!==void 0&&this.history.push(v)}moveUp(){this.y-=1,this.recordMove("^")}moveRight(){this.x+=1,this.recordMove(">")}moveDown(){this.y+=1,this.recordMove("v")}moveLeft(){this.x-=1,this.recordMove("<")}wait(){this.recordMove("w")}move(v){const t=this.copy();if(v==="^")t.moveUp();else if(v===">")t.moveRight();else if(v==="v")t.moveDown();else if(v==="<")t.moveLeft();else if(v==="w")t.wait();else throw`Direction '${v}' not recognised!`;return t}copy(){return this.history!==void 0?new o(this.x,this.y,this.length,[...this.history]):new o(this.x,this.y,this.length)}calculateDistanceFromEnd(v){this.distanceFromEnd=Math.abs(this.y-v.endY)+Math.abs(this.x-v.endX)}}function _(n,v,t){return n===t.startX&&v===t.startY}function x(n,v,t){return n===t.endX&&v===t.endY}function j(n,v,t){return n>=0&&n<t.width&&v>=0&&v<t.height}function k(n,v,t){return!t[v][n]}function h(n,v,t,e){return!!(_(n,v,t)||x(n,v,t)||j(n,v,t)&&k(n,v,e))}function R(n,v,t){n.debug&&(console.log("FAILED TO FIND BEST PATH! Info on current paths:"),v.forEach(e=>e.calculateDistanceFromEnd(t)),v.sort((e,r)=>e.distanceFromEnd-r.distanceFromEnd),console.log("Paths:",v.length),console.log("Best path:",v[0]),console.log("All paths:",v))}function q(n,v,t){return n.length>t.maxPaths&&(console.log("Pruned:",n.length-t.maxPaths),n.forEach(e=>e.calculateDistanceFromEnd(v)),n.sort((e,r)=>e.distanceFromEnd-r.distanceFromEnd),n=n.slice(0,maxPaths)),n}function G(n,v,t){for(const e of n)if(x(e.x,e.y,v))return t.debug&&(console.log("Final path:",e),console.log("Total paths at end:",n.length)),e}function J(n,v,t){const e=new Set;for(const r of n){const s=r.x+r.y*v.width;e.has(s)?r.length=-1:e.add(s)}return t.debug&&console.log("Duplicates:",n.length-e.size),n=n.filter(r=>r.length!==-1),n}function U(n,v,t,e){const r=t.getNextState(),s=[];for(const i of n)h(i.x,i.y,v,r)&&s.push(i.move("w")),h(i.x,i.y-1,v,r)&&s.push(i.move("^")),h(i.x+1,i.y,v,r)&&s.push(i.move(">")),h(i.x,i.y+1,v,r)&&s.push(i.move("v")),h(i.x-1,i.y,v,r)&&s.push(i.move("<"));return e.debug&&console.log(`Paths after step ${t.currentState}: ${n.length}`),s}function C(n){return n=JSON.parse(JSON.stringify(n)),[n.startX,n.startY,n.endX,n.endY]=[n.endX,n.endY,n.startX,n.startY],n}const H={maxPaths:1e3,maxStates:5e3,debug:!1,reversed:!1};function l(n,v,t){let e=H;t!==void 0&&(e=JSON.parse(JSON.stringify(e)),e=Object.assign(e,t)),e.reversed&&(n=C(n));let r=[o.atStart(n,e.debug)];[n.height,n.width]=[v.height,v.width];const s=v.currentState;for(;v.currentState<e.maxStates+s;){r=U(r,n,v,e),r=J(r,n,e);const i=G(r,n,e);if(i!==void 0)return i.length;r=q(r,n,e)}throw R(e,r,n),"No solution found within time limit settings.maxStates!"}function c(n){return n.trim().replaceAll("\r","").split(`
`).slice(1,-1).map(v=>v.replaceAll("#",""))}function V(n){const v=new b(n),t={startX:0,startY:-1,endX:v.width-1,endY:v.height};return l(t,v,{debug:!1})}function W(n){const v=new b(n),t={startX:0,startY:-1,endX:v.width-1,endY:v.height},e=!1,r=l(t,v,{debug:e}),s=l(t,v,{debug:e,reversed:!0}),i=l(t,v,{debug:e});return r+s+i}const K=`#.########################################################################################################################\r
#><^.^>v^<><^<>>>^<>><>v>^v<^>>^v<>>..<<><v<<>v>v>>^^v.v><>v>v^^v>>vv^<<v<>v^<v<.v<vvv<<v>>^vv.^vv>.>^..^v<<>^^<v<v^v^v<.#\r
#>>v^^v^><.<<.^v<v>.><>^<<>^v^<vvv><v<<<v^vv><vv>>>v^.>>^<>><^<><v>>>.^v^>.><>^^<v^>>>v>^.<>>v^^v^^^<<.^.<v>>^>><>.><<>v>#\r
#>>^<^>^^<<>^<<^v^^v^<<<^.<<^v><>.vvv^.^<v>^v>>v>^v<>><<>v<vv<^v<v^<^>><<<>>.v<^>vv.vv^v<^^<vv.><>^>.vv^v<>><<>vv^v><.>^<#\r
#>v<v^v<.>^.><<<<v>vv^^<^>v<^^^<<v<<v.^v<^>^v^<v<<<<v<v><.v^><<<^><.><..v>^^v<^<<v<^>^v<<>v^>>^^^^>v>>vv^<v.<v<v.>^^.>vv<#\r
#>>^<v>.<^<v>^<v.^^.v<v>>v>.>>.>v^<<<<<v^<^<<<>>^<^^v.<^><>><^<>>v<^v^>^v^.<v^>v<>^<<<<<^^^<v.<<v<v><.<..v.<v<v.<.^>v^^><#\r
#<^^^v<<v<.<^.^<<^>^>>><v^^.^v<v^^.vv^vvv^^>>^^.<^>v^v<^v<<>><.v><<>v>>v<<.^><^v<<>v.<^^^vv.<v^><>>.<vvv<v.>.>v<v<^^^<.v>#\r
#<<v<^^v>^>v><v>v^<<.^vv><>v^v<vv<vvv^^<<>>v>^.<..v>><<^vvv<>^v<<^.<^><.v><^<^v<v>.>^vv^^<<>v>>>.vv^<>v^>.<>.^><vvv^<<>^<#\r
#<<<v>^^<^<^v.><>^vv><^>v.v<>.<vv.>><^<^^<v.^v..^>>..v<^.>v>><^>vv^>>^<^.<.^v<>vv<<v.<<v><^^^v^>^v>^v>^.>>>v<>^vv>^^^^^^>#\r
#>>..><v><<>.^>>v>v^>><^<><^<<<vv>vv^v<vv<>.^vv.vvvv>>^^>^^<^>..><vvv^^<.^v^.<.^<<>^v<^^^<^><v^><^v^>>^><..>^>^>^<^.^<v<>#\r
#>^^..^v>v<^>>>><<.^^>^<><<><^^^><<>>^^><^^<<^v^^.<vv.vv<><>v.^<vv^v^v>^<<<.><vv^<.v^^v^^.>.>><..v<<^>v.^<.<<v>^<>.<.vvv<#\r
#<>>>>^^^vv^v<<<v.v^v>>v.<<^^.^^^>v<^>.<>^>.^v<<^<>^><>^<>^^.^<<v^^.><vv<^<><<.^<^>.^>v<>>>vv>^v^><^<<<>.>v>>^<>^^>^v<^v>#\r
#<><v^>>v>>^.^>>.<^v.>>><^^^><><>v^<<vvv><>v<<.^v>^>^v^>^^^><^^vv^^^<.<<v^v<><^^^<>v>^vv>>.v^>.^<v<>.>><<v^v<<^>^.v<v.<<>#\r
#<v<^^><<<>vvvvv<^^v<>^v.>vv<<>^<<>>>><>>>.vv>>^^v^>^<^>v^v^.^^<v^^>^.<><vvv.v.v><<<>><><>v<<<>^^><v^<.v>v<>^.>>v^<v^v<^<#\r
#>^^v>.<v<.v>^^v^<<>v>>.^>^>vv><v<><<^<>^v><.^<<<vvv.>>>.<^.^^>^^v<<>^>^<^><<^^^^vv^>><>>>><.<vvv^>>v.vv^..^<v.><vv>v>>.<#\r
#>^>^<v^v<vvv<^v^^<^<<>><..^^v<<v<>v>v.^<<<^v^^><v>>>^.^^^vv<^^><^.v^.>^><<.<<.<>^vvv<^>^<<v<.>v>^vvvvvv^^.^><>.>>.><..><#\r
#>><>^^>.>^^^^>>v<v<><^><>>>^^^^>^.>^^>>.<<v>v>>>v<<>><v><^.v^v^v>><>v<v<^^<.>>>^<^^vvv.>v^<>^>^v<v^>v>.><v^^^v>^v>>v^^<>#\r
#><<><<v.v^^>.vvvv>>^^>vv>.<^v.>.vv^v^..vvv^^>>v^^vvvvv<<v>.<^<>vv>><^<>v>.<>v.^>^<.>^^<^.>^<<v^v.<.>vv^^<.^vv>v<vv<.>^^>#\r
#><>^v<^vv>^.<^v<v>^<v.vv<<^v<v^^>^^>><<<v<<v^.vv><<>>v^<^>>>><<.vvv<v^v>^<^>v>^^^.^^>v<^v^v^^<<<><^<v<^^v><v>>vv<vv>>>^>#\r
#<^vv<<vv>.<>>^>v^vv^v<^v<vv<vv>^v.<v<^>>^>v>>>v^>.>^>v.<<<v.^>vv^.<>v<vv<><^^^>.>>>^v^^v<v^v>^>^vvv>>v^v^>>v^^^<><v>^>>>#\r
#>>><<^<.<v.v>>.v^<><<>>^v.>vvv^<v><vv>^<^v<<>.^<<v.vv<^^^><>^>>v>^vv^<<><>>^vvvv<<v<v><.^^^>^<>>v>.^<>.<v<<v<>^v^^^<v>v.#\r
#><^^>>><v.^><>>.^v^<<.>v<<<...<<^<>.v><vv>.<<.>^^>^.^<v^<>^>^>^v<v<.^v<<vvv^v.^.><v<v<v.v><<^v<<><>^<vvv.<><><v>.<v^^<.>#\r
#<><>^<<>v.^<.vvvvv<v^<^>^<^.>v>>.<^^vv^v.^<>^<>>v.^v<>v^^.>^^v>^<^<^<^<<<v<^<^^>>^^>^<.v<<>v<.^.<v><.>^<^^v>^>>.^^.^v^>>#\r
#>>.><^vv^><<>>v<v<><v<>^<^><vvv>.>^>>^.>^>v<>^<<<><..<>>.<v.<>^.v^^<<^^<>vvv<^v><><<<^>>v><<>.<v>>>^^>>.>><v^<^^^>v..v><#\r
#><vv<>.><<>^<v^^^>^.^^><^>>>^v<>vv<<^v<v>v.>>v^vv^<<v^v<^<.v^v>v.vv^>vv.>.<<<>^>^v.>v<v<^<^vv>vv^^<>>..v.>^><v<<vv^>v..<#\r
#><v>>>vvv<<<>>><^>^^>v<<v>^.><v<>^v><^<.v<v^<v<>^^><v.vv<..<>><>^v<<><<.^^v<>^<<><<.><v<>^<v.^<v^^^...>><>>^^^.>v^v^>vv>#\r
########################################################################################################################.#`,Q=`#.######\r
#>>.<^<#\r
#.<..<<#\r
#>v.><>#\r
#<^v^^>#\r
######.#\r
`;function Z(n){let v,t;return v=new N({props:{part1:V,part2:W,preprocessor:c,metadata:vv}}),{c(){z(v.$$.fragment)},l(e){$(v.$$.fragment,e)},m(e,r){B(v,e,r),t=!0},p:D,i(e){t||(I(v.$$.fragment,e),t=!0)},o(e){O(v.$$.fragment,e),t=!1},d(e){A(v,e)}}}const vv=Y;function tv(n){return F.set(c(K)),M.set(c(Q)),[]}class iv extends T{constructor(v){super(),P(this,v,tv,Z,E,{})}}export{iv as default,vv as myMetadata};
